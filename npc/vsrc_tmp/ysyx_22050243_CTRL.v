// RV32I
//   INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui    , U, R(dest) = imm);

//   INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc  , U, R(dest) = s->pc + imm);

//   INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu  , I, R(dest) = src1 < imm ? 1 : 0); // unsigned
//   INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi   , I, R(dest) = src1 + imm);
//   INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai   , I, R(dest) = SEXT((int64_t)src1 >> SEXT(BITS(imm, 5, 0), 64), 64));
//   INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli   , I, R(dest) = src1 >> SEXT(BITS(imm, 5, 0), 64));  
//   INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli   , I, R(dest) = src1 << SEXT(BITS(imm, 5, 0), 64));
//   INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi   , I, R(dest) = src1 & imm);
//   INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori   , I, R(dest) = src1 ^ imm);

//   INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add    , R, R(dest) = src1 + src2);
//   INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub    , R, R(dest) = src1 - src2);
//   INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul    , R, R(dest) = src1 * src2);
//   INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt    , R, R(dest) = (int64_t)src1 < (int64_t)src2 ? 1 : 0); // signed
//   INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu   , R, R(dest) = src1 < src2 ? 1 : 0); // unsigned
//   INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and    , R, R(dest) = src1 & src2); //
//   INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or     , R, R(dest) = src1 | src2); //

//   INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal    , J, R(dest) = s->pc +4; s->dnpc = s->pc+imm);

//   INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr   , I, R(dest) = s->pc +4; s->dnpc = (src1 + imm ) & (~1));

//   INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne    , B, if(src1 != src2) s->dnpc = s->pc + imm);
//   INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq    , B, if(src1 == src2) s->dnpc = s->pc + imm);
//   INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt    , B, if((int64_t)src1 < (int64_t)src2)  s->dnpc = s->pc + imm); // signed
//   INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu   , B, if(src1 <  src2) s->dnpc = s->pc + imm); // unsigned 
//   INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge    , B, if((int64_t)src1 >= (int64_t)src2) s->dnpc = s->pc + imm); // signed

//   INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld     , I, R(dest) = Mr(src1 + imm, 8));
//   INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw     , I, R(dest) = SEXT(Mr(src1 + imm, 4), 32));
//   INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh     , I, R(dest) = SEXT(Mr(src1 + imm, 2), 16));
//   INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu    , I, R(dest) = Mr(src1 + imm, 2)); //
//   INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu    , I, R(dest) = Mr(src1 + imm, 1)); //

//   INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd     , S, Mw(src1 + imm, 8, src2));
//   INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw     , S, Mw(src1 + imm, 4, (word_t)BITS(src2, 31, 0)));
//   INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh     , S, Mw(src1 + imm, 2, (word_t)BITS(src2, 15, 0)));
//   INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb     , S, Mw(src1 + imm, 1, (word_t)BITS(src2, 7, 0)));

//   INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak , N, NEMUTRAP(s->pc, R(10))); // R(10) is $a0
//   INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv    , N, INV(s->pc));

// RV64 I extended
//   INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw  , I, R(dest) = SEXT(BITS(src1 + imm, 31, 0), 32));
//   INSTPAT("010000? ????? ????? 101 ????? 00110 11", sraiw  , I, R(dest) = SEXT((int32_t)(BITS(src1,31,0)) >> SEXT(BITS(imm, 5, 0), 64), 32)); //
//   INSTPAT("000000? ????? ????? 101 ????? 00110 11", srliw  , I, R(dest) = SEXT((uint32_t)(BITS(src1,31,0)) >> SEXT(BITS(imm, 5, 0), 64), 32)); //
//   INSTPAT("000000? ????? ????? 001 ????? 00110 11", slliw  , I, R(dest) = SEXT(src1 << SEXT(BITS(imm, 5, 0), 64),32)); //



//   INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw   , R, R(dest) = SEXT(BITS(src1 + src2, 31, 0), 32));
//   INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw   , R, R(dest) = SEXT((int32_t)(BITS(src1,31,0)) >> src2, 32)); //
//   INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw   , R, R(dest) = SEXT((uint32_t)(BITS(src1,31,0)) >> src2, 32)); //
//   INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw   , R, R(dest) = SEXT(src1 << SEXT(BITS(src2, 4, 0), 64), 32)); //
//   INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw   , R, R(dest) = SEXT(src1 - src2, 32));
//   INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw   , R, R(dest) = SEXT(src1 * src2, 32));
//   INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw   , R, R(dest) = SEXT(SEXT(BITS(src1, 31, 0), 64) / SEXT(BITS(src2, 31, 0), 64), 32));
//   INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw   , R, R(dest) = SEXT((int64_t)SEXT(BITS(src1, 31, 0), 64) % (int64_t)SEXT(BITS(src2, 31, 0), 64), 64)); 

module CTRL (
    input  wire [6:0] opcode, // INST[6:0]
    input  wire [2:0] funct3,
    output reg        alu_src,
    output reg  [2:0] alu_op
);